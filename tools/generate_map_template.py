#!/usr/bin/env python3
"""
generate_map_template.py - Map 檔案範本產生器

根據 SNMP 查詢結果產生 Map 檔案範本
"""

import sys
import argparse
import os
from typing import List, Dict

try:
    from pysnmp.hlapi import (
        SnmpEngine, CommunityData, UdpTransportTarget, ContextData,
        ObjectType, ObjectIdentity, bulkCmd
    )
except ImportError:
    print("錯誤: 缺少 pysnmp 套件")
    print("請執行: pip3 install pysnmp")
    sys.exit(1)


def get_interfaces(host: str, community: str, timeout: int = 5) -> List[Dict]:
    """
    取得設備所有介面
    
    Returns:
        介面列表 [{index, name}, ...]
    """
    print(f"正在查詢設備 {host} 的介面...")
    
    interfaces = []
    oid_ifdescr = '1.3.6.1.2.1.2.2.1.2'
    
    try:
        for (errorIndication, errorStatus, errorIndex, varBinds) in bulkCmd(
            SnmpEngine(),
            CommunityData(community, mpModel=1),
            UdpTransportTarget((host, 161), timeout=timeout, retries=1),
            ContextData(),
            0, 50,
            ObjectType(ObjectIdentity(oid_ifdescr)),
            lexicographicMode=False
        ):
            if errorIndication:
                print(f"錯誤: {errorIndication}")
                return []
            
            if errorStatus:
                print(f"SNMP 錯誤: {errorStatus.prettyPrint()}")
                return []
            
            for varBind in varBinds:
                oid_str = str(varBind[0])
                if_descr = str(varBind[1])
                
                # 解析介面索引
                parts = oid_str.split('.')
                if len(parts) > 0:
                    if_index = int(parts[-1])
                    interfaces.append({
                        'index': if_index,
                        'name': if_descr
                    })
        
        print(f"✓ 找到 {len(interfaces)} 個介面")
        return interfaces
    
    except Exception as e:
        print(f"查詢失敗: {e}")
        return []


def parse_interface_name(if_name: str, device_type: int) -> Dict:
    """
    解析介面名稱
    
    Args:
        if_name: 介面名稱
        device_type: 設備類型 (1=MX240, 2=MX960, 3=E320, 4=ACX7024)
    
    Returns:
        {slot, port, vpi, vci} 或 None
    """
    # E320: ge-1/2/0.3490
    # MX/ACX: ge-1/0/2:3490
    
    if device_type == 3:  # E320
        # 格式: ge-slot/port/pic.vci 或 xe-slot/port/pic.vci
        if '.' not in if_name:
            return None
        
        try:
            # 移除介面類型前綴
            parts = if_name.split('-', 1)[1]  # 移除 ge- 或 xe-
            path, vci = parts.split('.')
            slot, port, pic = path.split('/')
            
            return {
                'slot': int(slot),
                'port': int(port),
                'vpi': int(pic),  # E320 的 PIC 對應 VPI
                'vci': int(vci)
            }
        except:
            return None
    
    else:  # MX/ACX
        # 格式: ge-fpc/pic/port:vci
        if ':' not in if_name:
            return None
        
        try:
            parts = if_name.split('-', 1)[1]
            path, vci = parts.split(':')
            fpc, pic, port = path.split('/')
            
            return {
                'slot': int(fpc),   # FPC → Slot
                'port': int(port),
                'vpi': int(pic),    # PIC → VPI
                'vci': int(vci)
            }
        except:
            return None


def generate_map_file(host: str, community: str, device_type: int, 
                     output_file: str, timeout: int = 5):
    """
    產生 Map 檔案範本
    
    Args:
        host: 設備 IP
        community: SNMP Community
        device_type: 設備類型
        output_file: 輸出檔案路徑
        timeout: SNMP 超時時間
    """
    # 取得介面清單
    interfaces = get_interfaces(host, community, timeout)
    
    if not interfaces:
        print("✗ 無法取得介面清單")
        return False
    
    # 篩選有效的 VLAN 介面
    valid_interfaces = []
    for iface in interfaces:
        parsed = parse_interface_name(iface['name'], device_type)
        if parsed:
            valid_interfaces.append({
                'name': iface['name'],
                'parsed': parsed
            })
    
    if not valid_interfaces:
        print("✗ 沒有找到有效的 VLAN 介面")
        return False
    
    print(f"✓ 找到 {len(valid_interfaces)} 個有效 VLAN 介面")
    
    # 產生 Map 檔案
    device_names = {1: 'MX240', 2: 'MX960', 3: 'E320', 4: 'ACX7024'}
    device_name = device_names.get(device_type, 'Unknown')
    
    print(f"\n產生 Map 檔案: {output_file}")
    
    with open(output_file, 'w', encoding='utf-8') as f:
        # 寫入檔頭
        f.write(f"# Map File for {device_name} - {host}\n")
        f.write(f"# Generated by generate_map_template.py\n")
        f.write(f"#\n")
        f.write(f"# 格式: UserID,Slot_Port_VPI_VCI,Download_Upload(bps),AccountID\n")
        f.write(f"#\n")
        f.write(f"# 請編輯此檔案:\n")
        f.write(f"#   1. 設定實際的 UserID\n")
        f.write(f"#   2. 設定正確的頻寬 (Download_Upload)\n")
        f.write(f"#   3. 設定 AccountID (電話號碼或 Email)\n")
        f.write(f"#\n")
        f.write(f"# 常見頻寬:\n")
        f.write(f"#   102.4M/40.96M  → 102400_40960\n")
        f.write(f"#   51.2M/10.24M   → 51200_10240\n")
        f.write(f"#   25.6M/5.12M    → 25600_5120\n")
        f.write(f"#   10M/2M         → 10240_2048\n")
        f.write(f"#\n\n")
        
        # 寫入範本資料（前 20 個）
        count = 0
        for iface in valid_interfaces[:20]:
            p = iface['parsed']
            interface_str = f"{p['slot']}_{p['port']}_{p['vpi']}_{p['vci']}"
            user_id = f"user_{count+1:03d}"
            bandwidth = "102400_40960"  # 預設頻寬
            account = "0912345678"       # 預設帳號
            
            f.write(f"{user_id},{interface_str},{bandwidth},{account}\n")
            count += 1
        
        # 如果超過 20 個，寫入註解
        if len(valid_interfaces) > 20:
            f.write(f"\n# ... 還有 {len(valid_interfaces) - 20} 個介面未列出\n")
            f.write(f"# 請根據實際需求編輯此檔案\n")
    
    print(f"✓ Map 檔案已產生: {output_file}")
    print(f"  包含 {min(count, 20)} 筆範本資料")
    print(f"\n請編輯此檔案並設定:")
    print(f"  1. 實際的 UserID")
    print(f"  2. 正確的頻寬")
    print(f"  3. 實際的 AccountID")
    
    return True


def main():
    """主程式"""
    parser = argparse.ArgumentParser(
        description='Map 檔案範本產生器',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
使用範例:
  # MX240 設備
  python3 generate_map_template.py --host 61.64.191.74 --type 1 \\
    --output map_61.64.191.74.txt
  
  # E320 設備
  python3 generate_map_template.py --host 61.64.191.78 --type 3 \\
    --output map_61.64.191.78.txt
  
  # 指定 community 和 timeout
  python3 generate_map_template.py --host 61.64.191.78 --type 3 \\
    --community private --timeout 10 \\
    --output map_61.64.191.78.txt

設備類型:
  1 = MX240
  2 = MX960
  3 = E320
  4 = ACX7024
        """
    )
    
    parser.add_argument('--host', required=True, help='設備 IP 位址')
    parser.add_argument('--type', type=int, required=True, choices=[1,2,3,4],
                       help='設備類型 (1=MX240, 2=MX960, 3=E320, 4=ACX7024)')
    parser.add_argument('--output', required=True, help='輸出檔案路徑')
    parser.add_argument('--community', default='public', help='SNMP Community')
    parser.add_argument('--timeout', type=int, default=5, help='SNMP 超時時間（秒）')
    
    args = parser.parse_args()
    
    # 檢查輸出目錄
    output_dir = os.path.dirname(args.output)
    if output_dir and not os.path.exists(output_dir):
        print(f"建立目錄: {output_dir}")
        os.makedirs(output_dir, exist_ok=True)
    
    # 產生 Map 檔案
    success = generate_map_file(
        args.host,
        args.community,
        args.type,
        args.output,
        args.timeout
    )
    
    sys.exit(0 if success else 1)


if __name__ == '__main__':
    main()
